/*
 * This header file provides the OpenGL fragment shader for the AnyLine
 * routine.
 * 
 * AnyLine_FragmentShader1.h - Copyright Phillip Potter, 2020
 */
#ifndef PHILPSX_ANYLINE_FRAGMENTSHADER1
#define PHILPSX_ANYLINE_FRAGMENTSHADER1

static const char *GPU_getAnyLine_FragmentShader1Source(void)
{
	return
	"#version 450 core\n"
	"\n"
	"// Image corresponding to vram texture\n"
	"layout (binding = 1, rgba8ui) uniform uimage2D vramImage;\n"
	"\n"
	"// Uniforms to control drawing process\n"
	"layout (location = 10) uniform int semiTransparencyEnabled;\n"
	"layout (location = 11) uniform int semiTransparencyMode;\n"
	"layout (location = 12) uniform int setMask;\n"
	"layout (location = 13) uniform int checkMask;\n"
	"layout (location = 14) uniform int drawTopLeftX;\n"
	"layout (location = 15) uniform int drawTopLeftY;\n"
	"layout (location = 16) uniform int drawBottomRightX;\n"
	"layout (location = 17) uniform int drawBottomRightY;\n"
	"layout (location = 18) uniform int dither;\n"
	"\n"
	"// Input colour value\n"
	"in vec3 vertexColour;\n"
	"\n"
	"// Function declarations\n"
	"bool inDrawingArea(ivec2 pixelCoord);\n"
	"\n"
	"// Dummy output value\n"
	"out vec4 colour;\n"
	"\n"
	"// Convert pixel format and store in vram texture\n"
	"void main(void) {\n"
	"\n"
	"	// Get coordinate from gl_FragCoord\n"
	"	ivec2 tempDrawCoord = ivec2(gl_FragCoord.xy);\n"
	"\n"
	"	// Define line pixel variable, keeping it empty for now\n"
	"	//uvec4 linePixel = uvec4((uint(vertexColour.r) >> 3) & uint(0x1F),\n"
	"	//(uint(vertexColour.g) >> 3) & uint(0x1F),\n"
	"	//(uint(vertexColour.b) >> 3) & uint(0x1F), 0);\n"
	"	uvec4 linePixel = uvec4(0, 0, 0, 0);\n"
	"\n"
	"	// Merge pixel with interpolated colour\n"
	"	linePixel.r = int(vertexColour.r);\n"
	"	linePixel.g = int(vertexColour.g);\n"
	"	linePixel.b = int(vertexColour.b);\n"
	"		\n"
	"	// Check for dither bit\n"
	"	if (dither == 1) {\n"
	"\n"
	"		// Declare dither pixel as signed int vector as otherwise\n"
	"		// calculations will be off\n"
	"		ivec3 ditherPixel = ivec3(int(linePixel.r),\n"
	"								int(linePixel.g),\n"
	"								int(linePixel.b));\n"
	"\n"
	"		// Define dither offset array\n"
	"		int ditherArray[4][4];\n"
	"		ditherArray[0][0] = -4;\n"
	"		ditherArray[0][1] = 2;\n"
	"		ditherArray[0][2] = -3;\n"
	"		ditherArray[0][3] = +3;\n"
	"		ditherArray[1][0] = 0;\n"
	"		ditherArray[1][1] = -2;\n"
	"		ditherArray[1][2] = 1;\n"
	"		ditherArray[1][3] = -1;\n"
	"		ditherArray[2][0] = -3;\n"
	"		ditherArray[2][1] = 3;\n"
	"		ditherArray[2][2] = -4;\n"
	"		ditherArray[2][3] = 2;\n"
	"		ditherArray[3][0] = 1;\n"
	"		ditherArray[3][1] = -1;\n"
	"		ditherArray[3][2] = 0;\n"
	"		ditherArray[3][3] = -2;\n"
	"\n"
	"		// Calculate dither column and row\n"
	"		int ditherColumn = tempDrawCoord.x % 4;\n"
	"		int ditherRow = (511 - tempDrawCoord.y) % 4;\n"
	"\n"
	"		// Modify pixel\n"
	"		ditherPixel.r += ditherArray[ditherColumn][ditherRow];\n"
	"		ditherPixel.g += ditherArray[ditherColumn][ditherRow];\n"
	"		ditherPixel.b += ditherArray[ditherColumn][ditherRow];\n"
	"\n"
	"		if (ditherPixel.r < 0) {\n"
	"			ditherPixel.r = 0;\n"
	"		}\n"
	"		else if (ditherPixel.r > 0xFF) {\n"
	"			ditherPixel.r = 0xFF;\n"
	"		}\n"
	"\n"
	"		if (ditherPixel.g < 0) {\n"
	"			ditherPixel.g = 0;\n"
	"		}\n"
	"		else if (ditherPixel.g > 0xFF) {\n"
	"			ditherPixel.g = 0xFF;\n"
	"		}\n"
	"\n"
	"		if (ditherPixel.b < 0) {\n"
	"			ditherPixel.b = 0;\n"
	"		}\n"
	"		else if (ditherPixel.b > 0xFF) {\n"
	"			ditherPixel.b = 0xFF;\n"
	"		}\n"
	"\n"
	"		linePixel.r = uint(ditherPixel.r);\n"
	"		linePixel.g = uint(ditherPixel.g);\n"
	"		linePixel.b = uint(ditherPixel.b);\n"
	"	}\n"
	"\n"
	"	// Restore colours to original 15-bit format\n"
	"	linePixel.r = linePixel.r >> 3;\n"
	"	if (linePixel.r > 0x1F) {\n"
	"		linePixel.r = 0x1F;\n"
	"	}\n"
	"	linePixel.g = linePixel.g >> 3;\n"
	"	if (linePixel.g > 0x1F) {\n"
	"		linePixel.g = 0x1F;\n"
	"	}\n"
	"	linePixel.b = linePixel.b >> 3;\n"
	"	if (linePixel.b > 0x1F) {\n"
	"		linePixel.b = 0x1F;\n"
	"	}\n"
	"\n"
	"	// Load vram pixel\n"
	"	uvec4 vramPixel = imageLoad(vramImage, tempDrawCoord);\n"
	"\n"
	"	// Handle semi-transparency here if enabled\n"
	"	if (semiTransparencyEnabled == 1) {\n"
	"\n"
	"		int oldRed = int(vramPixel.r);\n"
	"		int oldGreen = int(vramPixel.g);\n"
	"		int oldBlue = int(vramPixel.b);\n"
	"\n"
	"		int newRed = int(linePixel.r);\n"
	"		int newGreen = int(linePixel.g);\n"
	"		int newBlue = int(linePixel.b);\n"
	"\n"
	"		// Do calculation\n"
	"		switch (semiTransparencyMode) {\n"
	"			case 0: // B/2 + F/2\n"
	"				newRed = oldRed / 2 + newRed / 2;\n"
	"				newGreen = oldGreen / 2 + newGreen / 2;\n"
	"				newBlue = oldBlue / 2 + newBlue / 2;\n"
	"				break;\n"
	"			case 1: // B + F\n"
	"				newRed = oldRed + newRed;\n"
	"				newGreen = oldGreen + newGreen;\n"
	"				newBlue = oldBlue + newBlue;\n"
	"				break;\n"
	"			case 2: // B - F\n"
	"				newRed = oldRed - newRed;\n"
	"				newGreen = oldGreen - newGreen;\n"
	"				newBlue = oldBlue - newBlue;\n"
	"				break;\n"
	"			case 3: // B + F/4\n"
	"				newRed = oldRed + newRed / 4;\n"
	"				newGreen = oldGreen + newGreen / 4;\n"
	"				newBlue = oldBlue + newBlue / 4;\n"
	"				break;\n"
	"		}\n"
	"\n"
	"		// Saturate pixel\n"
	"		if (newRed < 0) {\n"
	"			newRed = 0;\n"
	"		}\n"
	"		else if (newRed > 31) {\n"
	"			newRed = 31;\n"
	"		}\n"
	"\n"
	"		if (newGreen < 0) {\n"
	"			newGreen = 0;\n"
	"		}\n"
	"		else if (newGreen > 31) {\n"
	"			newGreen = 31;\n"
	"		}\n"
	"\n"
	"		if (newBlue < 0) {\n"
	"			newBlue = 0;\n"
	"		}\n"
	"		else if (newBlue > 31) {\n"
	"			newBlue = 31;\n"
	"		}\n"
	"\n"
	"		// Store new pixel values\n"
	"		linePixel.r = newRed;\n"
	"		linePixel.g = newGreen;\n"
	"		linePixel.b = newBlue;\n"
	"	}\n"
	"\n"
	"	// Set mask bit if enabled\n"
	"	if (setMask == 1) {\n"
	"		linePixel.a = 0x1;\n"
	"	}\n"
	"\n"
	"	// Check vram pixel if enabled, else just merge, also checking\n"
	"	// line pixel is in draw area\n"
	"	bool inArea = inDrawingArea(tempDrawCoord);\n"
	"	if (checkMask == 1) {\n"
	"		if (vramPixel.a != 1 && inArea) {\n"
	"			imageStore(vramImage, tempDrawCoord, linePixel);\n"
	"		}\n"
	"	}\n"
	"	else if (inArea) {\n"
	"		imageStore(vramImage, tempDrawCoord, linePixel);\n"
	"	}\n"
	"\n"
	"	// Set dummy output value\n"
	"	colour = vec4(0.0, 0.0, 0.0, 0.0);\n"
	"}\n"
	"\n"
	"// Tells us if a pixel is in the drawing area\n"
	"bool inDrawingArea(ivec2 pixelCoord) {\n"
	"	bool retVal = false;\n"
	"	if (pixelCoord.x >= drawTopLeftX &&\n"
	"		pixelCoord.x <= drawBottomRightX &&\n"
	"		pixelCoord.y <= drawTopLeftY &&\n"
	"		pixelCoord.y >= drawBottomRightY) {\n"
	"		retVal = true;\n"
	"	}\n"
	"\n"
	"	return retVal;\n"
	"}\n";
}

#endif